# 背包问题

## 概述

- 01背包：有Ｎ件物品和一个质量为Ｍ的背包（每种物品均只有一件）。第ｉ件物品的质量是w[i]，价值是p[i]，求解将哪些物品装入背包可使得总价值最高.       
- 完全背包：有Ｎ种物品和一个质量为Ｍ的背包（每种物品都有无限件可用。第ｉ种物品的质量是w[i]，价值是p[i]，求解将哪些物品装入背包中可使得这些物品的总价值最高              
- 多重背包：有Ｎ种物品和一个质量为Ｍ的背包，第ｉ中物品最多有n[i]件可用，每件的重量为w[i]，价值为p[i]，求解将哪些物品装入背包可使得物品的总价值最高   

## 0/1背包问题

####题目

    有Ｎ件物品和一个容量为Ｖ的背包，第ｉ件物品的费用是c[i]，价值是w[i]，求解将哪些物品装入背包可使总价值最高.

#### 基本思路

    这是最基础的背包问题，特点是每种物品仅有一件，可以选择放还是不放。　　　　　　　　　　
    用子问题定义状态：即f[i][v]表示前ｉ件物品恰好放入一个容量为ｖ的背包可以获得的最大价值。则其状态转换方程为：　　　　　　　　
    *f[i][v] = max{f[i-1][v], f[i-1][v-c[i]] + w[i]}*              

    这个方程非常重要，基本上是将所有跟背包问题有关的问题的方程都是由它衍生出来的：将前ｉ件物品放入容量为ｖ的背包中，若是只考虑第ｉ个物品放或者不放，那么就可以转化为一个只牵扯到前ｉ－１件物品的问题。如果不放入背包中，那么可以变为将前i-1件物品放入容量为v的背包中，此时能够获得的最大价值就是f[i-1][v]；若是放入背包，那么问题转化为将前i-1件物品放入容量为v-c[i]的背包中的问题，此时能够获得的最大价值就是f[i-1][v-c[i]+w[i].              

#### 优化空间复杂度

    以上方法的时间和空间复杂度均为O(VN)，其中时间复杂度应该已经不能再优化了，但是空间复杂度却可以优化到O(N)。　　　　　　　　　　　　　
    先考虑基本思路的实现，需要一个主循环i=1,2,3,...,N，每次算出来二维数组f[i][0...V]的所有值，那么，如果只用一个数组f[0...V]，能否保证第i次循环结束后f[v]中表示的就是所定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]决定的，那么能否保证在推导f[i][v]的时候，f[i-1][v]和f[i-1][v-c[i]]已经确定？事实上我们可以使用以下这种方式：                        

```c
for(int i = 1; i <= N; i++)
    for(int v = V; v >= 1; v--)
        f[v] = max{ f[v], f[v-c[i]]+w[i]};
```
    注意：这个方法是通过ｆ数组利用第ｉ－１轮刷新后和第ｉ轮刷新前这个空当，实现一维数组完成背包的记录，但是需要注意的是，在每一轮主循环中，ｖ必须是反过来的，否则就会变成f[i][v]是通过f[i-1][v]和f[i][v-c[i]]求的。

    这个方法是针对空间复杂度的优化，对于Ｖ比较大的时候会比较有用，而对于时间并不会减少！！！




  

